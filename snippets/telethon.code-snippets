{
    "Telethon Starters [Bot]": {
        "prefix": "tgbot",
        "body":[
        "# BoilerPlate Generated using https://github.com/xditya/TelethonSnippets Extension.",
        "# Dependencies to be pre-installed: ",
        "# - telethon: Telegram Library.", 
        "# - python-decouple: To load config vars from .env files or environment variables.",
        "",
        "import logging",
        "",
        "from decouple import config",
        "from telethon import TelegramClient, events",
        "",
        "# initializing logger",
        "logging.basicConfig(",
        "    level=logging.INFO, format=\"[%(levelname)s] %(asctime)s - %(message)s\"",
        ")",
        "log = logging.getLogger(\"TelethonSnippets\")",
        "",
        "# fetching variales from env",
        "try:",
        "    BOT_TOKEN = config(\"BOT_TOKEN\")",
        "except BaseException as ex:",
        "    log.info(ex)",
        "",
        "",
        "log.info(\"Connecting bot.\")",
        "try:",
        "    bot = TelegramClient(None, 6, \"eb06d4abfb49dc3eeb1aeb98ae0f581e\").start(",
        "        bot_token=BOT_TOKEN",
        "    )",
        "except BaseException as e:",
        "    log.warning(e)",
        "    exit(1)",
        "",
        "\n# functions",
        "@bot.on(events.NewMessage(incoming=True, pattern=\"^/start\"))",
        "async def new_start(event):",
        "# Make the bot reply to \/start command.",
        "   await event.reply(\"Hello, I'm online!\")",
        "",
        "",
        "bot_self = bot.loop.run_until_complete(bot.get_me())",
        "log.info(\"\\nBot has started as @%s.\\n\", bot_self.username)",
        "bot.run_until_disconnected()"
    ]
    },
    "Telethon Starters [UserBot]": {
        "prefix": "tgubot",
        "body":[
            "# BoilerPlate Generated using https://github.com/xditya/TelethonSnippets Extension.",
        "# Dependencies to be pre-installed: ",
        "# - telethon: Telegram Library.", 
        "# - python-decouple: To load config vars from .env files or environment variables.",
        "",
        "import logging",
        "",
        "from decouple import config",
        "from telethon import TelegramClient, events",
        "from telethon.sessions import StringSession",
        "",
        "# initializing logger",
        "logging.basicConfig(",
        "    level=logging.INFO, format=\"[%(levelname)s] %(asctime)s - %(message)s\"",
        ")",
        "log = logging.getLogger(\"TelethonSnippets\")",
        "",
        "# fetching variales from env",
        "try:",
        "    API_ID = config(\"API_ID\", cast=int)",
        "    API_HASH = config(\"API_HASH\")",
        "    SESSION = config(\"SESSION\")",
        "except BaseException as ex:",
        "    log.info(ex)",
        "",
        "",
        "log.info(\"Connecting bot.\")",
        "try:",
        "    client = TelegramClient(StringSession(SESSION), api_id=API_ID, api_hash=API_HASH).start()",
        "except BaseException as e:",
        "    log.warning(e)",
        "    exit(1)",
        "",
        "",
        "\n# functions",
        "@client.on(events.NewMessage(outgoing=True, pattern=\"^.alive\"))",
        "async def new_alive(event):",
        "# Make the userbotbot edit an outgoing .alive message.",
        "   await event.edit(\"Hello, I'm online!\")",
        "",
        "",
        "ubot_self = client.loop.run_until_complete(client.get_me())",
        "log.info(\"\\nClient has started as %d.\\n\", ubot_self.id)",
        "client.run_until_disconnected()"
        ]
    },
    "Telethon Event [NewMessage event]": {
        "prefix": "tgcmd",
        "body": [
            "@bot.on(events.NewMessage(pattern=\"$1\"))",
            "async def command_handler_event(event):",
            "# event handlers for command: $1",
            "",
        ]
    }
}